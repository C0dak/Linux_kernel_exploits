import angr
from angr import concretization_strategies
import claripy
import simuvex
import state_broker
import traceback
from pwn import *

debug_qemu_backend=1 # init state with register from the qemu instance
debug_irsb=0 # show irsb information
debug_after_address_concretization=0
resolve_uninit=1 # loading uninitialized memory from qemu instance
use_custom_concretization_strategy_first=1 # use custom_concretization_strategy

pause_on_each_step=0
pause_on_uninit_write=0
pause_on_finish_memory_loading=0
pause_on_read_from_symbolic_address=0
pause_on_write_to_symbolic_address=1
dump_userspace_buffer=1
dump_uaf_buffer=1


KERNEL_PATH = '/home/ww9210/kernels/4.10-no-kasan/vmlinux' 
QEMU_PORT = 9210
#start_addr = 0xffffffff811d3d76 #0xffffffff811d3d76 lea    rbx,[rax-0xd8]
start_addr = 0xffffffff811d3d50 #0xffffffff811d3d50 <timerfd_clock_was_set>: push   rbp
#uaf_object_base can only be determined based on current system state
uaf_object_base = 0xffff88003d6916d8-0xd8
uaf_object_size = 0xf0
userspace_base = 0xfacea000
'''
this script is invoked after the use is found to find potentially exploitable "use" of vulnerable object after the first use found by KASAN
the key challenge for this executor is to glue angr with gdb and previous vulnerability key information seamlessly.
We set a breakpoint for the initial use found by the fuzzer, and start concolic execution to see if the use is exploitable or some other uses after the use is exploitable
'''
'''
   0xffffffff811d3d6e <timerfd_clock_was_set+30> cmp    rax, 0xffffffff81e5f160
   0xffffffff811d3d74 <timerfd_clock_was_set+36> je     0xffffffff811d3df1 <timerfd_clock_was_set+161>
   0xffffffff811d3d76 <timerfd_clock_was_set+38> lea    rbx, [rax-0xd8]
   0xffffffff811d3d7d <timerfd_clock_was_set+45> jmp    0xffffffff811d3d95 <timerfd_clock_was_set+69>
   0xffffffff811d3d7f <timerfd_clock_was_set+47> mov    rax, QWORD PTR [rbx+0xd8]
   0xffffffff811d3d86 <timerfd_clock_was_set+54> cmp    rax, 0xffffffff81e5f160
   0xffffffff811d3d86 <timerfd_clock_was_set+54> cmp    rax, 0xffffffff81e5f160
   0xffffffff811d3d8c <timerfd_clock_was_set+60> lea    rbx, [rax-0xd8]
   0xffffffff811d3d93 <timerfd_clock_was_set+67> je     0xffffffff811d3df1 <timerfd_clock_was_set+161>
   0xffffffff811d3d95 <timerfd_clock_was_set+69> cmp    BYTE PTR [rbx+0xe8], 0x0
   0xffffffff811d3d9c <timerfd_clock_was_set+76> je     0xffffffff811d3d7f <timerfd_clock_was_set+47>
   0xffffffff811d3d9e <timerfd_clock_was_set+78> lea    r12, [rbx+0xa0]
'''
def dump_reg(state):
    print 'rax:', state.regs.rax
    print 'rbx:', state.regs.rbx
    print 'rcx:', state.regs.rcx
    print 'rdx:', state.regs.rdx
    print 'rsi:', state.regs.rsi
    print 'rdi:', state.regs.rdi
    print 'rsp:', state.regs.rsp
    return

def debug_state(b, state):# project and state
    try:
        irsb = b.factory.block(state.addr).vex
        cap = b.factory.block(state.addr).capstone
        irsb.pp()
        cap.pp()
    except angr.errors.SimEngineError:
        print 'angr.errors.SimEngineError'
        pass
        #import IPython; IPython.embed()
    #sirsb = b.factory.sim_block(state)
    #print type(sirsb)
    #import IPython; IPython.embed()
    #dump_sirsb(sirsb)
    #s.inspect.b('exit', when=simuvex.BP_AFTER, action='ipython')
    #s.inspect.b('exit', when=simuvex.BP_AFTER, action = debug_func)
    #b.factory.sim_run(state)

def debug_simgr(b,simgr):
    print 'active:'
    for state in simgr.stashes['active']:
        debug_state(b,state)
     

'''
simgr=b.factory.simgr(s)
while len(simgr.active) == 1:
    simgr.step()
    import IPython; IPython.embed()
#simgr.run(n=2)
import IPython; IPython.embed()
#step until the first symbolic branch
while len(simgr.active) == 1:
    simgr.step()'''
def resolve_read(state):
    raise NotImplementError
    return


#the following code does not work anymore in new version of angr
def explore_a_path(b,s):
    p = b.factory.path(state=s)
    assert p.addr==start_addr
    loop_idx=0
    while True:
        loop_idx+=1
        prev_state=p.state
        print '[+] '+str(loop_idx)+' step() at '+hex(p.addr)
        simsuccessors=p.step()
        new_state=p.state
        debug_state(b,prev_state)
        #import IPython; IPython.embed()
        raw_input()
        for succ in simsuccessors.successors:
            print succ
            p = succ

def explore_by_pathgroup(b,s):
    simgr=b.factory.simgr(s,save_unconstrained=True)
    #simgr.use_technique
    loop_idx=0
    while True:
        print '[+] '+str(loop_idx)+' step()'
        debug_simgr(b,simgr)
        try:
            simgr.step()
        except:
            print 'wtf another angr bug :('
            traceback.print_exc()
            import IPython; IPython.embed()
            return 
        loop_idx+=1
        #import IPython; IPython.embed()
        if simgr.unconstrained:
            print '[+] unconstrained state found!'
            import IPython; IPython.embed()
        if pause_on_each_step:
            raw_input('step?<-')
    #simgr.run()

def set_concret_memory_region(s,addr,buf,length):
    aligned_addr = addr & 0xfffffffffffff000
    s.memory.store(aligned_addr, buf, inspect = False)
    #for i in range(length):
        #s.memory.store(aligned_addr + i, s.se.BVV(buf[i], 8), inspect = False)
    return

def get_stack():
    return
      
def init_reg_concrete(r,s):
    s.regs.rax = s.se.BVV(state_broker.get_register(r,"rax"), 64)
    s.regs.rbx = s.se.BVV(state_broker.get_register(r,"rbx"), 64)
    s.regs.rcx = s.se.BVV(state_broker.get_register(r,"rcx"), 64)
    s.regs.rdx = s.se.BVV(state_broker.get_register(r,"rdx"), 64)
    s.regs.rsi = s.se.BVV(state_broker.get_register(r,"rsi"), 64)
    s.regs.rdi = s.se.BVV(state_broker.get_register(r,"rdi"), 64)
    s.regs.rsp = s.se.BVV(state_broker.get_register(r,"rsp"), 64)
    s.regs.rbp = s.se.BVV(state_broker.get_register(r,"rbp"), 64)
    s.regs.r8  = s.se.BVV(state_broker.get_register(r,"r8") , 64)
    s.regs.r9  = s.se.BVV(state_broker.get_register(r,"r9") , 64)
    s.regs.r10 = s.se.BVV(state_broker.get_register(r,"r10"), 64)
    s.regs.r11 = s.se.BVV(state_broker.get_register(r,"r11"), 64)
    s.regs.r12 = s.se.BVV(state_broker.get_register(r,"r12"), 64)
    s.regs.r13 = s.se.BVV(state_broker.get_register(r,"r13"), 64)
    s.regs.r14 = s.se.BVV(state_broker.get_register(r,"r14"), 64)
    s.regs.r15 = s.se.BVV(state_broker.get_register(r,"r15"), 64)
    s.regs.rip = s.se.BVV(state_broker.get_register(r,"rip"), 64)
    return s

def install_context(r,s):
    '''
    init the blank state with register value from real context
    '''
    s=init_reg_concrete(r,s)
    return s

def track_reads(state):
    global b    # <- the kernel project
    global sol  # <- the solver object
    #print 'temporarily disable breakpoint'
    #state.inspect.remove_breakpoint('mem_read',bp1)
    print '='*78
    print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address,\
            'Size', state.inspect.mem_read_length
    try:
        if debug_irsb:
            irsb = b.factory.block(state.addr).vex
            irsb.pp()
        cap = b.factory.block(state.addr).capstone
        cap.pp()
        dump_reg(state)
        print 'uninit:', state.inspect.mem_read_address.uninitialized,\
                'symbolic:', state.inspect.mem_read_address.symbolic
        #if state.inspect.mem_read_address.uninitialized:
            #print 'read from uninitialized address, primitive found!'
            #raw_input('wtf read from uninitialized addres')
        if state.inspect.mem_read_address.symbolic:
            print 'read from symbolic address, primitive found!'
            if pause_on_read_from_symbolic_address:
                raw_input('wtf read from symbolic address')
            return
        print 'checking whether memory is uninitialized...'
        t=state.memory.load(state.inspect.mem_read_address,size=1,inspect=False)
        if (t.uninitialized and not state.inspect.mem_read_address.symbolic):
            print 'memory content uninit: ', t.uninitialized, \
                    'memory content symbolic: ', t.symbolic
            print '[+] uninitialized memory read found:', state.inspect.mem_read_address
            print '[+] the uninitialized memory read is at:', hex(state.addr)
            if resolve_uninit:
                r = remote('127.0.0.1',9210)
                addr=sol.eval(state.inspect.mem_read_address.get_bytes(0,8),1)[0]
                print '[+] resolving a page containing the address:', hex(addr)
                con = state_broker.get_a_page(r, addr)
                r.close()
                set_concret_memory_region(state, addr, con, 4096)
                print '[+] resolved the uninit with concrete page'
                #import IPython; IPython.embed()
                if pause_on_finish_memory_loading:
                    raw_input('do the read now(continue) <-')
        else:
            print 'Memory Content does not appear uninitialized.'

            #import IPython; IPython.embed()
    except AttributeError:
        pass
    #import IPython; IPython.embed()
    #raw_input('continue<-')
    return

def track_writes(state):
    global b
    print '='*78
    print 'Write', state.inspect.mem_write_expr, 'to', state.inspect.mem_write_address,\
            'size', state.inspect.mem_write_length
    if debug_irsb:
        irsb = b.factory.block(state.addr).vex
        irsb.pp()
    cap = b.factory.block(state.addr).capstone
    cap.pp()
    try:
        print state.inspect.mem_write_address.uninitialized,\
                state.inspect.mem_write_address.symbolic
        if state.inspect.mem_write_address.symbolic:
            print '[+] write to symbolic address, primitive found!'
            if pause_on_write_to_symbolic_address:
                opt=raw_input('ipython shell? [y/n]')
                if opt=='y\n':
                    import IPython; IPython.embed()
        if state.inspect.mem_write_address.uninitialized:
            print 'write to uninitialized address, primitive found!'
            if pause_on_uninit_write:
                raw_input('wtf uninitialzed write')
    except AttributeError:
        pass
    #import IPython; IPython.embed()
    #raw_input('continue')
    return

def track_reg_read(state):
    print 'Reg_Read', state.inspect.reg_read_expr, 'from', state.inspect.reg_read_offset,\
            'length', state.inspect.reg_read_length
    # note we can not use state.addr here because it will create recursion problem accessing related instruction pointer register
    '''
    cap = b.factory.block(state.addr).capstone
    cap.pp()
    '''
    #raw_input('do the reg_read now? <-')
    return

def track_symbolic_variable(state):
    print 'Symbolic_Variable:' , state.inspect.symbolic_name, 'size:', \
            state.inspect.symbolic_size, 'symbolic expr:', \
            state.inspect.symbolic_expr
    return

def address_concretization_before(state):
    print '='*78
    print 'state.addr', hex(state.addr)
    print 'Address_Concretization strategy:',\
            state.inspect.address_concretization_strategy
    print 'Address concretization action:',\
            state.inspect.address_concretization_action
    print 'address_concretization_memory:',\
            state.inspect.address_concretization_memory,
    print 'address_concretization_expr:',\
            state.inspect.address_concretization_expr
    #import IPython; IPython.embed()
    #state.inspect.address_concretization_strategy=None
    return

def address_concretization_after(state):
    print 'address_concretization_result:',\
            state.inspect.address_concretization_result
    if state.inspect.address_concretization_action =='load':
        print('address_concretization_action: load')
    if debug_after_address_concretization:
        opt=raw_input('ipython shell? [y/n]')
        if opt=='y\n':
            import IPython; IPython.embed()
    print '='*78
    '''
    opt=raw_input('ipython shell? [y/n]')
    if opt=='y\n':
        import IPython; IPython.embed()
    '''

    return

def add_stack_pivot_constraint(state):
    print '[+] checking the possibilities of stack pivot...'
    s = state.copy()
    s.add_constraints(s.regs.rip==0xdeadbeeffacefbad)
    print s.solver.constraints
    for _ in s.actions:
        print _
    assert s.satisfiable()
    uaf_buf = s.memory.load(uaf_object_base, uaf_object_size, inspect=False)
    userspace_buf = s.memory.load(userspace_base, 4096, inspect=False)
    con1 = s.solver.eval(uaf_buf, cast_to=str)
    print 'the UAF object:',con1.encode('hex')
    if dump_uaf_buffer:
        file('uaf_object.bin','w').write(con1)
        print '[+] uaf object dumped to file.  '
    con2 =  s.solver.eval(userspace_buf, cast_to=str)
    print 'the userspace_buf:',con2.encode('hex')
    if dump_userspace_buffer:
        file('userspace_buffer.bin','w').write(con2)
        print '[+] userspace buffer dumped to file.'
    #import IPython; IPython.embed()
    return

def track_call(state):
    '''
    in this callback, we can not use state.addr to get current ip as it might be symbolic, if the rip is symbolic, we have found an exploitable primitive
    '''
    global b
    print '='*78
    print 'Call instruction at:', state.inspect.function_address
    if state.regs.rip.symbolic:
        print '[+] control flow hijack found'
        add_stack_pivot_constraint(state)#
        opt=raw_input('ipython shell? [y/n]')
        if opt=='y\n':
            import IPython; IPython.embed()
    '''
    opt=raw_input('do function call now? <- ')
    if opt=='y\n':
        import IPython; IPython.embed()
    cap = b.factory.block(state.addr).capstone
    cap.pp()
    '''
    return

def install_section(r,s,name):
    global k
    section = k.get_section_by_name(name)
    section_offset = section.header['sh_addr']
    section_length = section.header['sh_size']
    if section_length % 4096 != 0:
        section_length = ((section_length / 4096) + 1) * 4096
    num_of_page = section_length / 4096
    print 'installing',num_of_page, 'pages of section:', name
    for i in range(num_of_page):
        #print i
        addr = section_offset + i * 4096
        con = state_broker.get_a_page(r, section_offset + i*4096)
        set_concret_memory_region(s, addr, con, 4096)
    print 'Finished installing section:', name
    return

def concretization_cond(state):
    return state.addr == 0xffffffff8109a62a

def add_concretization_strategy(state):
    state.memory.read_strategies.insert(\
            0, concretization_strategies.SimConcretizationStrategyKuafffp(0xfacea000,4096)
    )
    return

def concretize_call_before(state):
    print '='*78
    print 'state.addr', hex(state.addr)
    print 'Address_Concretization strategy:',\
            state.inspect.address_concretization_strategy
    print 'Address concretization action:',\
            state.inspect.address_concretization_action
    print 'address_concretization_memory:',\
            state.inspect.address_concretization_memory,
    print 'address_concretization_expr:',\
            state.inspect.address_concretization_expr
    traceback.print_stack()
    #import IPython; IPython.embed()
    #print '[+] changing concretizer to our custom one:'
    #state.inspect.address_concretization_strategy=angr.concretization_strategies.SimConcretizationStrategyKuafffp(userspace_base, 4096)
    return

def concretize_call_after(state):
    print '='*78
    print 'Address_Concretization strategy:',\
            state.inspect.address_concretization_strategy
    print 'address_concretization_result:',\
            state.inspect.address_concretization_result
    #print '[+] restoring default concretizer...'
    #state.inspect.address_concretization_strategy=\
            #angr.concretization_strategies.SimConcretizationStrategyAny()
    if state.inspect.address_concretization_action =='load':
        print('address_concretization_action: load')
    opt = raw_input('ipython shell? [y/n]')
    if opt=='y\n':
        import IPython; IPython.embed()
    return

def add_instrumentation(s):
    s.inspect.b('mem_read', when=angr.BP_BEFORE, action=track_reads)
    s.inspect.b('mem_write', when=angr.BP_BEFORE, action=track_writes)
    #s.inspect.b('reg_read', when=angr.BP_BEFORE, action=track_reg_read)
    s.inspect.b('call', when=angr.BP_BEFORE, action=track_call)
    s.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=track_symbolic_variable)
    s.inspect.b('address_concretization', when=angr.BP_BEFORE, action=address_concretization_before)
    s.inspect.b('address_concretization', when=angr.BP_AFTER, action=address_concretization_after)
    s.inspect.b('address_concretization', when=angr.BP_BEFORE, action=concretize_call_before, condition=concretization_cond)
    s.inspect.b('address_concretization', when=angr.BP_AFTER, action=concretize_call_after, condition=concretization_cond)

def main():
    global b
    global sol
    extras = {angr.options.REVERSE_MEMORY_NAME_MAP, \
				angr.options.TRACK_ACTION_HISTORY, \
				angr.options.CONSTRAINT_TRACKING_IN_SOLVER} 
    s = b.factory.blank_state(addr = start_addr, add_options=extras)
    if use_custom_concretization_strategy_first:
        #add_concretization_strategy(s, 0xffffffff8109a62a)
        add_concretization_strategy(s)
         
    add_instrumentation(s)

    if debug_qemu_backend:
        r = remote('127.0.0.1', QEMU_PORT)
        s = install_context(r, s)
        install_section(r, s, '.data')
        install_section(r, s, '.bss')
        install_section(r, s, '.brk')
        r.close()
    s.memory.store(uaf_object_base,s.se.BVS("uaf_obj", uaf_object_size*8))
    raw_input('Start conclic exploration?')
    explore_by_pathgroup(b,s)

if __name__=='__main__':
    k=ELF(KERNEL_PATH)    
    b = angr.Project(KERNEL_PATH)
    sol = claripy.Solver()
    main()
