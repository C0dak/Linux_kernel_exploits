# concolic execution
prototype concolic execution engine using gdb and qemu gdb-stub, with reference to the symgdb implementation

1. Get debugged program state by calling GDB Python API
2. Get the current program state and yield to triton
3. Set Symbolic Variable
4. Set the target address
5. Run symbolic execution
6. Inject back to debugged program state

## the story
Based on the PoC, we started a customized fuzzing to find the new use for the use-after-free vulnerability. The KASan log usually indicates that the UAF is triggerd by reading the freed object. To explore more powerful usage of the freed object , we use concolic exploration from the context found by the fuzzer..
## the implementation
We use angr to work with context extracted from qemu for partial concolic execution starting from the function of the new use found by the customized syzkaller, we set the freed object region as symbolic.

## the dependency
the state_broker has dependency on pwntools
