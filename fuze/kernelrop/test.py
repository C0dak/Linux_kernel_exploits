#!/usr/bin/python
from pwn import *
import subprocess
import ropgadget
from ropgadget.binary import Binary
from capstone import CS_MODE_32
import re

KERNEL_PATH='/home/ww9210/kernels/4.10-no-kasan/vmlinux'
KERNEL_PATH='/home/ww9210/kernels/4.10-inject-10150-no-kasan/vmlinux'
cmd= ('--binary ' + KERNEL_PATH + ' --depth 3')\
        .split(' ')
#subprocess.call(cmd.split(' '))
from   ropgadget.args import Args
from   ropgadget.core import Core
c=Core(Args(arguments=cmd).getArgs())
#import IPython; IPython.embed()


def is_stack_pivot(gadget):
    ''' when choosing a stack pivot gadget is that it needs to be aligned by 8 bytes (since the ops is the array of 8 byte pointers and its base address is properly aligned)'''
    vaddr = gadget["vaddr"]
    insts = gadget["gadget"]
    if len(insts.split(';')) != 2:
        return False

    if vaddr%8!=0:
        return False

    regex = re.compile(r'xchg e\w\w, esp ; ret[\S]*')
    if regex.search(insts)==None:
        return False

    return True

def custom_looingForGadgets(core):
    if core._Core__checksBeforeManipulations()==False:
        return False
    arch = core._Core__binary.getArchMode()
    print("Gadgets information\n============================================================")
    for gadget in core._Core__gadgets:
        vaddr = gadget["vaddr"]
        insts = gadget["gadget"]
        if is_stack_pivot(gadget):
            print(("0x%08x" %(vaddr) if arch == CS_MODE_32 else "0x%016x" %(vaddr)) + " : %s" %(insts))

    return True


def custom_analysis(core):
    try:
        core._Core__offset = int(core._Core__options.offset, 16) if core._Core__options.offset else 0
    except ValueError:
        print("[Error] The offset must be in hexadecimal")
        return Fa
    if core._Core__options.console:
        if core._Core__options.binary:
            core._Core__binary = Binary(core._Core__options)
            if core._Core__checksBeforeManipulations() == False:
                return False
        core.cmdloop()
        return T
    core._Core__binary = Binary(core._Core__options)
    if core._Core__checksBeforeManipulations() == False:
        return Fa
    if   core._Core__options.string:   return core._Core__lookingForAString(core._Core__options.string)
    elif core._Core__options.opcode:   return core._Core__lookingForOpcodes(core._Core__options.opcode)
    elif core._Core__options.memstr:   return core._Core__lookingForMemStr(core._Core__options.memstr)
    else: 
        core._Core__getAllgadgets()
        core._Core__lookingForGadgets()
        #custom_looingForGadgets(core)
        if core._Core__options.ropchain:
            ROPMaker(core._Core__binary, core.__gadgets, core.__offset)
        return True

custom_analysis(c)



